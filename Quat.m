(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(*
   Quaternions package implements Hamilton\[CloseCurlyQuote]s quaternion algebra.
   This package mimics original Mathematica Quaternions.m, however, 
   it fixes various bugs and also allows symbolic transformations
   of quaternions to more extent than Mathematica's original.
   Author:  Mikica B Kocic
   Version: 0.4, 2012-04-22
*)


$Pre =.


BeginPackage[ "Quat`" ];


Unprotect[ Quat`\[ScriptCapitalQ] ];


ClearAll[ "Quat`Private`*" ];
ClearAll[ "Quat`*" ];


\[ScriptCapitalQ]::usage = "\[ScriptCapitalQ][w,x,y,z] represents the quaternion with real part w \
(also called scalar part) and imaginary part {x,y,z} (also called vector part)";


\[ScriptCapitalQ]Q::usage = "\[ScriptCapitalQ]Q[q] gives True if q is a quaternion, \
and False otherwise.";


To\[ScriptCapitalQ]::usage = "To\[ScriptCapitalQ][expr] transforms expr into a quaternion object if at all possible.";


ScalarQ::usage = "ScalarQ[q] gives True if q is a scalar, and False otherwise.";


ToList::usage = "ToList[q] gives components of q in a list";


ToVector::usage = "ToVector[q] gives q as column vector matrix";


ToMatrix::usage = "ToMatrix[q] gives matrix representation of quaternion q";


Abs$Im::usage = "Abs$Im[q] gives the absolute value of the vector quaternion part of q.";


AdjustedSign$Im::usage = "AdjustedSign$Im[q] gives the Sign of the vector part of q, \
adjusted so its first non-zero part is positive.";


NonCommutativeMultiply::usage = "Implements non-commuatative quaternion multiplication.";


To\[ScriptCapitalQ]$AngleAxis::usage = "To\[ScriptCapitalQ]$AngleAxis[\[Theta],{ux,uy,uz}] transforms axis \!\(\*
StyleBox[\"u\",\nFontWeight->\"Bold\"]\) and angle \[Theta] into quaternion";


To\[ScriptCapitalQ]::invargs = "To\[ScriptCapitalQ]: failed to construct \[ScriptCapitalQ] from argument:\n args \[Equal] `1`"


RotationMatrix4::usage = "RotationMatrix4[q] gives the 4\[Cross]4 rotation matrix for a \
counterclockwise 3D rotation around the quaterion q"


QForm::usage = "QForm[q] prints with the elements of matrix or quaternion \
arranged in a regular array."


Assert::usage = "QForm[q] prints with the elements of matrix or quaternion \
arranged in a regular array."


Begin[ "Quat`Private`" ];


Subscript[ q_ ?\[ScriptCapitalQ]Q, n_Integer /; 1 <= n <= 4 ] := q[[n]]


AngleBracket[ q_ ?\[ScriptCapitalQ]Q ] := Re[q]


OverVector[ q_ ?\[ScriptCapitalQ]Q ] := q[[2;;4]] /. \[ScriptCapitalQ] -> List


OverHat[ q_ ?\[ScriptCapitalQ]Q ] := q / Abs[ q ]


SuperStar[ q_ ?\[ScriptCapitalQ]Q ] := Conjugate[ q ]


BracketingBar[ q_ ?\[ScriptCapitalQ]Q ] := Abs[ q ]


SetAttributes[ TimeIt, HoldAll ];


TimeIt[ expr_ ] :=
Module[ 
  { result = expr, out, form },
  If[ TrueQ[ MemberQ[ $OutputForms, Head[result] ] ],
    (* Then *) out = First[result]; form = "//" <> ToString[ Head[result] ], 
    (* Else *) out = result; form = ""
  ];
  If[ out =!= Null,
    CellPrint[
      ExpressionCell[ result, "Output", 
        CellLabelAutoDelete -> True,
        CellLabel -> StringJoin[ "Out[", ToString[$Line], "]:="]
      ]
    ];
    Unprotect[ Out ];
    Out[ $Line ] = out;
    Protect[ Out ];
    out (* needed for % *)
  ];
];


Assert[ statement_, params__: Null ] := 
Module[
  { result },
  (* Try to proove the statement... *)
  result = statement;
  If[ result, 
    (* is true *)  Return@ Style[ "\[RightTee] True \[FilledRectangle]", Blue ],
    (* is false *) Return@ Style[ "False \[SadSmiley]", Red, Large, Bold ],
    (* is neither true or false *) Null (* continue... *)
  ];
  (* ... now, try even harder to proove the statement *)
  result = Simplify[ statement,params ];
  If[ result, 
    (* is true *)  Return@ Style[ "\[RightTee] True (after Simplify) \[FilledRectangle]", Blue ],
    (* is false *) Return@ Style[ "False (after Simplify) \[SadSmiley]", Red, Large, Bold ],
    (* is neither true or false *) Null (* continue... *)
  ];
  (* ... now, try even harder to proove the statement *)
  result = FullSimplify[ statement, params ];
  If[ result,
    (* is true *)  Style[ "\[RightTee] True (after FullSimplify) \[FilledRectangle]", Blue ],
    (* is false *) Style[ "False (after FullSimplify) \[SadSmiley]", Red, Large, Bold ],
    (* is neither true or false *)
	    Style[ "Indeterminate \[FreakedSmiley]", Darker[Red], Large, Bold ]
  ]
]


ScalarQ[ x_ ] := AtomQ[ x ] \[Or] Length[ x ] === 0 \[Or]
  ( Length[ x ] =!= 0 \[And] \[Not]ListQ[ x ] \[And] Head[ x ] =!= \[ScriptCapitalQ] \[And] Head[ x ] =!= Complex )  


\[ScriptCapitalQ]Q[ q_ ] := 
  Head[ q ] === \[ScriptCapitalQ] \[And] Length[ q ] === 4 \[And]
  And @@ ( ScalarQ /@ q )


To\[ScriptCapitalQ][ w_ ?ScalarQ, { x_ ?ScalarQ, y_ ?ScalarQ, z_ ?ScalarQ } ] := 
    \[ScriptCapitalQ][ w, x, y, z ]


To\[ScriptCapitalQ][ q_ ] := q /. {
    \[ScriptCapitalQ][ w_, x_, y_, z_ ] :> \[ScriptCapitalQ][ w, x, y, z ],
    { x_ ?ScalarQ, y_ ?ScalarQ, z_ ?ScalarQ }  :> \[ScriptCapitalQ][ 0, x, y, z ],
    { w_ ?ScalarQ, x_ ?ScalarQ, y_ ?ScalarQ, z_ ?ScalarQ } :> \[ScriptCapitalQ][ w, x, y, z ],
    { {w_ ?ScalarQ}, {x_ ?ScalarQ}, {y_ ?ScalarQ}, {z_ ?ScalarQ} } :> \[ScriptCapitalQ][ w, x, y, z ],
    Complex[ x_, y_ ] :> \[ScriptCapitalQ][ x, y, 0, 0 ],
    Plus[ x_, Times[ Complex[ 0, 1 ], y_ ] ] :> \[ScriptCapitalQ][ x, y, 0, 0 ],
    Times[ Complex[ 0, 1 ], x_ ] :> \[ScriptCapitalQ][ 0, x, 0,  0 ],
    Times[ Complex[ 0, x_ ], y_ ] :> \[ScriptCapitalQ][ 0, x y, 0, 0 ],
    x_ ?ScalarQ :> \[ScriptCapitalQ][ x, 0, 0, 0],
    (* unknown list *)
    list_ :> Module[ {}, Message[ To\[ScriptCapitalQ]::invargs, list ]; Abort[] ]
} // \[ScriptCapitalQ]Simplify


To\[ScriptCapitalQ]$AngleAxis[ \[Theta]_, { ux_, uy_, uz_ } ] := \[ScriptCapitalQ][
    Cos[\[Theta]/2], ux Sin[\[Theta]/2], uy Sin[\[Theta]/2], uz Sin[\[Theta]/2]
]


ToList[ q_ ?\[ScriptCapitalQ]Q ] := ( q /. \[ScriptCapitalQ]-> List )


ToVector[ q_ ?\[ScriptCapitalQ]Q ] := Transpose@{ q /. \[ScriptCapitalQ]-> List }


ToMatrix[ \[ScriptCapitalQ][ w_, x_, y_, z_ ] ] := {
   {  w,  x,  y,  z },
   { -x,  w, -z,  y },
   { -y,  z,  w, -x },
   { -z, -y,  x,  w }
}


\[ScriptCapitalQ] /: MatrixForm[ q: \[ScriptCapitalQ][ __ ?ScalarQ ] ] := MatrixForm@ ToList@ q


QForm[ Q_ ?MatrixQ ] := DisplayForm@
  RowBox[{
    "(", "\[NoBreak]",
    GridBox[ Release[ Q ],
      RowSpacings -> 1, ColumnSpacings -> 1,
      RowAlignments -> Baseline,
      ColumnAlignments -> Center,
      GridBoxDividers -> {
        "Columns" -> { False, GrayLevel[0.84] },
        "Rows" -> { False, GrayLevel[0.84] }
      }
   ],
   "\[NoBreak]", ")"
 }]


QForm[ q_ ?\[ScriptCapitalQ]Q ] := QForm[ { Release[ ToList@ q ] } ]


\[ScriptCapitalQ] /: RotationMatrix[ \[ScriptCapitalQ][ w_, x_, y_, z_ ] ] :=
{
   {  1 - 2( y^2 + z^2 ),   2 x y - 2 w z,     2 x z + 2 w y  },
   {  2 x y + 2 w z,     1 - 2( x^2 + z^2 ),  2 y z - 2 w x   },
   {  2 x z - 2 w y ,    2 w x+2 y z,      1 - 2( x^2 + y^2 ) }
}


\[ScriptCapitalQ] /: RotationMatrix4[ \[ScriptCapitalQ][ w_, x_, y_, z_ ] ] :=
{
   {  1,  0,                  0,                 0                },
   {  0,  1 - 2( y^2 + z^2 ),   2 x y - 2 w z,    2 x z + 2 w y   },
   {  0,  2 x y + 2 w z,     1 - 2( x^2 + z^2 ),  2 y z - 2 w x   },
   {  0,  2 x z - 2 w y ,    2 w x + 2 y z,    1 - 2( x^2 + y^2 ) }
}


\[ScriptCapitalQ] /: Conjugate[ \[ScriptCapitalQ][ w_, x_, y_, z_ ] ]:=
    \[ScriptCapitalQ][ w, -x, -y, -z ]


\[ScriptCapitalQ] /: SqNorm[ q:  \[ScriptCapitalQ][ __ ?ScalarQ ] ] := 
    Plus @@ ( ( List @@ q )^2 )


\[ScriptCapitalQ] /: Norm[ q: \[ScriptCapitalQ][ __ ?ScalarQ ] ]:=
    Sqrt[ SqNorm[ q ] ]


\[ScriptCapitalQ] /: Abs[ q:  \[ScriptCapitalQ][ __ ?ScalarQ ] ] := 
    Sqrt[ SqNorm[ q ] ]


\[ScriptCapitalQ] /: Round[ q: \[ScriptCapitalQ][ __ ?ScalarQ ] ]:=
Module[
  { 
    cent = Round /@ q;
    mid = ( Floor /@ q ) + \[ScriptCapitalQ][ 1/2, 1/2, 1/2, 1/2 ];
  },
  If[ SqNorm[ q - cent ] <= SqNorm[ q - mid ], cent, mid ]
]


\[ScriptCapitalQ] /: Re[ q: \[ScriptCapitalQ][ __ ?ScalarQ ] ] :=
    q[[1]]


\[ScriptCapitalQ] /: Sign[ q: \[ScriptCapitalQ][ __ ?ScalarQ ] ] := 
    \[ScriptCapitalQ][ 1, 0, 0, 0 ] /; Abs[ q ] == 0


\[ScriptCapitalQ] /: Sign[ q: \[ScriptCapitalQ][ __ ?ScalarQ ] ] :=
    q / Abs[ q ]


\[ScriptCapitalQ] /: Im[ q: \[ScriptCapitalQ][ __ ?ScalarQ ] ] :=
    { q[[2]], q[[3]], q[[4]] }


AdjustedSign$Im[ q_Complex | q_ ?ScalarQ ] := I


AdjustedSign$Im[ \[ScriptCapitalQ][ w_ ?ScalarQ, x_ ?ScalarQ, y_ ?ScalarQ, z_ ?ScalarQ ] ] :=
Which[
    x != 0,
        Sign[ x ] * Sign[ \[ScriptCapitalQ][ 0, x, y, z ] ],
    y != 0,
        Sign[ y ] * Sign[ \[ScriptCapitalQ][ 0, x, y, z ] ],
    z != 0,
        Sign[ z ] * Sign[ \[ScriptCapitalQ][ 0, x, y, z ] ],
    True,
        I (* ?abort? *)
]


Abs$Im[ \[ScriptCapitalQ][ w_ ?ScalarQ, x_ ?ScalarQ, y_ ?ScalarQ, z_ ?ScalarQ ] ]:=
    Sqrt[x^2 + y^2 + z^2]


Abs$Im[ x_ ? NumericQ ] := 
    Im[ x ]


Sign$Im[ \[ScriptCapitalQ][ w_ ?ScalarQ, x_ ?ScalarQ, y_ ?ScalarQ, z_ ?ScalarQ ] ] :=
    Sign[ \[ScriptCapitalQ][ 0, x, y, z ] ]


\[ScriptCapitalQ] /: \[ScriptCapitalQ][ w1_, x1_, y1_, z1_ ] + \[ScriptCapitalQ][ w2_, x2_, y2_, z2_ ] :=
    \[ScriptCapitalQ][ w1 + w2, x1 + x2, y1 + y2, z1 + z2 ] // \[ScriptCapitalQ]Simplify


\[ScriptCapitalQ] /: Complex[ re_, im_ ] + \[ScriptCapitalQ][ w_, x_, y_, z_ ] :=
    \[ScriptCapitalQ][ w + re, x + im, y, z ] // \[ScriptCapitalQ]Simplify


\[ScriptCapitalQ] /: \[Lambda]_ ?ScalarQ + \[ScriptCapitalQ][ w_, x_, y_, z_ ] := 
    \[ScriptCapitalQ][ w + \[Lambda], x, y, z ]


\[ScriptCapitalQ] /: \[Lambda]_ ?ScalarQ * \[ScriptCapitalQ][ w_, x_, y_, z_ ]:= 
    \[ScriptCapitalQ][ \[Lambda] w, \[Lambda] x, \[Lambda] y, \[Lambda] z ]


\[ScriptCapitalQ] /: \[ScriptCapitalQ][ w1_, x1_, y1_, z1_ ] ** \[ScriptCapitalQ][ w2_, x2_, y2_, z2_ ]:=
    \[ScriptCapitalQ][
        w1 w2 - x1 x2 - y1 y2 - z1 z2,
        w1 x2 + x1 w2 + y1 z2 - z1 y2,
        w1 y2 - x1 z2 + y1 w2 + z1 x2,
        w1 z2 + x1 y2 - y1 x2 + z1 w2
    ] // \[ScriptCapitalQ]Simplify


Unprotect[ NonCommutativeMultiply ]
(*SetAttributes[ NonCommutativeMultiply, Listable ]*)


a_ ?ScalarQ ** b_ ?\[ScriptCapitalQ]Q := a * b


a_ ?\[ScriptCapitalQ]Q ** b_ ?ScalarQ := a * b


{ x_ ?ScalarQ, y_ ?ScalarQ, z_ ?ScalarQ } ** q_ ?\[ScriptCapitalQ]Q := 
    \[ScriptCapitalQ][ 0, x, y, z ] ** q


q_ ?\[ScriptCapitalQ]Q ** { x_ ?ScalarQ, y_ ?ScalarQ, z_ ?ScalarQ } := 
    q ** \[ScriptCapitalQ][ 0, x, y, z ]


{ w_ ?ScalarQ, x_ ?ScalarQ, y_ ?ScalarQ, z_ ?ScalarQ } ** q_ ?\[ScriptCapitalQ]Q := 
    \[ScriptCapitalQ][ w, x, y, z ] ** q


q_ ?\[ScriptCapitalQ]Q ** { w_ ?ScalarQ, x_ ?ScalarQ, y_ ?ScalarQ, z_ ?ScalarQ } := 
    q ** \[ScriptCapitalQ][ w, x, y, z ]


{ {w_ ?ScalarQ}, {x_ ?ScalarQ}, {y_ ?ScalarQ}, {z_ ?ScalarQ} } ** q_ ?\[ScriptCapitalQ]Q :=
    \[ScriptCapitalQ][ w, x, y, z ] ** q


q_ ?\[ScriptCapitalQ]Q ** { {w_ ?ScalarQ}, {x_ ?ScalarQ}, {y_ ?ScalarQ}, {z_ ?ScalarQ} } := 
    q ** \[ScriptCapitalQ][ w, x, y, z ]


( ( a_: 1 ) * Complex[ b_, c_ ] ) ** ( ( x_: 1 ) * Complex[ y_, z_ ] ) :=
    a b x y - a c x z + ( a c x y + a b x z ) I


( x_ + y_ ) ** a_ := ( x ** a ) + ( y ** a )
a_ ** (x_ + y_) := ( a ** x ) + ( a ** y )


Protect[ NonCommutativeMultiply ]


extfunc[ func_, a_, b_ ] :=
    Re[b] + Abs$Im[b] * AdjustedSign$Im[a]


Block[
    { extend, $Output = {} },

    extend[ foo_ ]:= (
        Unprotect[ foo ];
        \[ScriptCapitalQ] /: foo[ a: \[ScriptCapitalQ][ __ ?ScalarQ ] ] :=
           extfunc[ foo, a, foo[ Re[a] + Abs$Im[a] * I ] ];
        Protect[ foo ];
    );

    extend /@ {
        Log,
        Cos, Sin, Tan, Sec, Csc, Cot,
        ArcCos, ArcSin, ArcTan, ArcSec, ArcCsc, ArcCot,
        Cosh, Sinh, Tanh, Sech, Csch, Coth,
        ArcCosh, ArcSinh, ArcTanh, ArcSech, ArcCsch, ArcCoth
    };
]


\[ScriptCapitalQ] /: Exp[ q: \[ScriptCapitalQ][ __ ?ScalarQ ] ] :=
    Exp[ Re[ q] ] * 
    ( Cos[ Abs$Im[ q ] ] + Sin[ Abs$Im[ q ] ] * Sign$Im[ q] ) // \[ScriptCapitalQ]Simplify


\[ScriptCapitalQ] /: Power[ q: \[ScriptCapitalQ][ __ ?ScalarQ ], 0 ] :=
    1


\[ScriptCapitalQ] /: Power[ q: \[ScriptCapitalQ][ __ ?ScalarQ ], 1 ] :=
    q


\[ScriptCapitalQ] /: Power[ q: \[ScriptCapitalQ][ __ ?ScalarQ ], -1 ] :=
    Conjugate[q] ** ( 1 / SqNorm[q] )


\[ScriptCapitalQ] /: Power[ q: \[ScriptCapitalQ][ __ ?ScalarQ ], n_ ] :=
    q ** Power[ q, n - 1 ] /; n > 1 \[And] n \[Element] Integers


\[ScriptCapitalQ] /: Power[ q: \[ScriptCapitalQ][ __ ?ScalarQ ], n_ ] :=
    Power[ 1/q, -n ] /; n < 0 \[And] n != -1


\[ScriptCapitalQ] /: Power[ q: \[ScriptCapitalQ][ __ ?ScalarQ ], n_ ] :=
Module[
  {
    \[Mu] = Abs[ q ], (* modulus of {Subscript[q, 1],Subscript[q, 2],Subscript[q, 3],Subscript[q, 4]} *)
    re = Re[ q ], (* scalar part re = {Subscript[q, 1]} *)
    im = Abs$Im[ q ], (* modulus of vector part im = {Subscript[q, 2],Subscript[q, 3],Subscript[q, 4]} *)
    \[Theta], (* Angle between vector im and scalar re *)
    \[Phi] = 0, (* Angle between Subscript[q, 2] and vector part {Subscript[q, 2],Subscript[q, 3],Subscript[q, 4]} *)
    \[Gamma] = 0 (* Angle between Subscript[q, 3] and subvector {Subscript[q, 3],Subscript[q, 4]} *)
  },

  \[Theta] = If[ re =!= 0, 
        (* Then *) ArcTan[ im / re ],
        (* Else *) \[Pi]/2
      ];

  If[ im =!= 0,
  (* Then *)
     \[Phi] = ArcCos[ q[[2]] / im ];
     \[Gamma] = If[ Sin[\[Phi]] =!= 0,
         (* Then *)
            ArcCos[ q[[3]] / ( im Sin[\[Phi]] ) ] Sign[ q[[4]] ],
            ( \[Pi]/2 ) Sign[ q[[4]] ]
         ]
  ];

  \[ScriptCapitalQ][
     \[Mu]^n Cos[ n \[Theta] ] ,
     \[Mu]^n Sin[ n \[Theta] ] Cos[\[Phi]] ,
     \[Mu]^n Sin[ n \[Theta] ] Sin[\[Phi]] Cos[\[Gamma]],
     \[Mu]^n Sin[ n \[Theta] ] Sin[\[Phi]] Sin[\[Gamma]] 
  ]  // \[ScriptCapitalQ]Simplify

] /; ScalarQ[n] \[And] n > 0


\[ScriptCapitalQ] /: Power[ E, q: \[ScriptCapitalQ][ __ ?ScalarQ ] ] :=
    Exp[ q ]


\[ScriptCapitalQ] /: Sqrt[ q: \[ScriptCapitalQ][ __ ?ScalarQ ] ] :=
    Power[ q, 1/2 ]


\[ScriptCapitalQ] /: Divide[ left: \[ScriptCapitalQ][ __ ?ScalarQ ], right : \[ScriptCapitalQ][ __ ?ScalarQ ] ] :=
    left ** ( Conjugate[right] ** 1/SqNorm[right] )


\[ScriptCapitalQ] /: \[ScriptCapitalQ]Simplify[ q: \[ScriptCapitalQ][ __ ?ScalarQ ] ] :=
  Simplify[ TrigExpand /@ q ]


\[ScriptCapitalQ]Simplify[ q_ ] := q


$Pre = TimeIt;


End[];


EndPackage[];
